(* Generated by esgg output from reverse_nested_agg/query.json based on reverse_nested_agg/mapping.json *)
type 'key doc_count = { key: 'key; doc_count: int }
type 'a buckets = { buckets: 'a list }
type int_as_float =
  float wrap <ocaml t="int" wrap="int_of_float" unwrap="float_of_int">
type 'a value_agg' = { value: 'a }
type 'a value_agg =
  'a value_agg' wrap
    <ocaml
       t="'a" wrap="fun { value; } -> value" unwrap="fun value -> { value; }">
type basic_json <ocaml module="Json" t="t"> = abstract
type role = { role_id: int wrap <ocaml module="Obj.Roles.Role_id"> }
type obj_elem = {
  user_id: int wrap <ocaml module="Obj.User_id">;
  user_name: string wrap <ocaml module="Obj.User_name">;
  ~roles: role list
}
type _source = {
  name: string wrap <ocaml module="Name">;
  ~obj: obj_elem list
}
type hit = { _id: string; _source: _source }
type hits = { total: int; ~hits: hit list }
type name = { name: string wrap <ocaml module="Name"> }
type hit1 = { _id: string; _source: name }
type hits1 = { total: int; ~hits: hit1 list }
type keyword = { hits: hits1 }
type users_keywords = {
  key: int <ocaml repr="int64"> wrap <ocaml module="Name.Hash">;
  doc_count: int;
  keyword: keyword
}
type top_level = { doc_count: int; users_keywords: users_keywords buckets }
type users = {
  key: int wrap <ocaml module="Obj.User_id">;
  doc_count: int;
  top_level: top_level
}
type _source1 = { _source: obj_elem }
type hits2 = { total: int; ~hits: _source1 list }
type roles_user_names = { hits: hits2 }
type obj_level = { doc_count: int; roles_user_names: roles_user_names }
type roles = {
  key: int wrap <ocaml module="Obj.Roles.Role_id">;
  doc_count: int;
  obj_level: obj_level
}
type into_roles = { doc_count: int; roles: roles buckets }
type into_obj = {
  doc_count: int;
  users: users buckets;
  into_roles: into_roles
}
type aggregations = { into_obj: into_obj }
type result = { hits: hits; aggregations: aggregations }
